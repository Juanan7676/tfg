\def\Z{\mathbb{Z}}
\def\C{\mathbb{C}}
\def\R{\mathbb{R}}
\def\ket#1{| #1 \rangle}

\chapter{El algoritmo de Shor}

\section{Introducción}
El objetivo de este capítulo es describir el (principal) algoritmo que pone en peligro toda la criptografía clásica que se usa actualmente en gran medida: el algoritmo de Shor, que permite factorizar cualquier número natural en $O((\log N)^3)$ pasos (\cite{quantuminformation}, pág. 233), donde $N$ es el número a factorizar. El algoritmo contiene dos partes, una parte clásica que se ejecutaría en un ordenador clásico, y una parte cuántica que se ejecutaría en un ordenador cuántico. La idea clave del algoritmo subyace en el siguiente resultado.

\bproposicion
\label{prop1}
Sea $N$ un número compuesto de $L$ bits, y sea $x\in \mathbb{Z}_N$ con \\ $1<x<N-1$ una solución de la ecuación
\begin{equation} \label{eqcuadrados} x^2 = 1\mod N \end{equation}
Entonces, o bien $\mcd(x-1,N)$ o bien $\mcd(x+1,N)$ es un factor no trivial de $N$ y se puede calcular en $O(L^3)$ operaciones.
\eproposicion
\begin{proof}
	Ya que $x^2 - 1 = 0 \mod N$, entonces $N|_{(x^2+1)=(x+1)(x-1)}$. De aquí, $N$ debe tener un factor común con $(x+1)$ ó con $(x-1)$, es decir, $\mcd(x+1,N)>1$ ó $\mcd(x-1,N)>1$. Además, ya que $1 < x < N-1$, entonces $2 < x+1 < N$ y $0 < x-1 < N-2$, en cualquier caso, $x-1 < N$ y $x+1 < N$ y por tanto $\mcd(x-1,N) < N$ y $\mcd(x+1,N) < N$. Esto prueba que ninguno puede ser un factor trivial de $N$. Mediante el algoritmo de Euclides, estos factores pueden calcularse en $O(L^3)$ operaciones (ver \cite{quantuminformation}, pág. 629).
\end{proof}

En general, encontrar una solución de \eqref{eqcuadrados} es difícil. Sin embargo, existe una estrategia para abordar este problema. Si $1 < y < N-1$ es cualquier número coprimo con $N$ y resulta que el orden $r$ del elemento $y$ dentro del grupo multiplicativo $(\mathbb{Z}/N\mathbb{Z})^*$ (es decir, el menor natural tal que $y^r = 1 \mod N$) es par, entonces $y^{r/2}$ sería una solución de \eqref{eqcuadrados}; y además cumpliría las hipótesis de la Proposición \ref{prop1} si $ y^{r/2} \neq - 1 \mod N $ (observemos que no puede ser $1$, ya que ello contradiría la definición de $r$). Resulta que si escogemos este número $y$ aleatoriamente entre $2$ y $N-2$ (si no es coprimo con $N$, entonces habríamos encontrado un factor calculando $\mcd(y,N)$), entonces es muy probable que verifique las condiciones expuestas, lo cual nos permitiría calcular los factores como enuncia la Proposición \ref{prop1}. Este hecho se recoge en el siguiente teorema.

\bteoremaa
\label{teoremaprob}
Sea $N = p_1^{\alpha_1}p_2^{\alpha_2}\cdots p_m^{\alpha_m}$ una factorización en números primos de un número impar. Sea $x$ un elemento escogido aleatoriamente de $(\mathbb{Z}/N\mathbb{Z})^*$, y sea $r$ el orden de $x$ módulo $N$. Entonces,
\[ P[\mbox{r es par y que }x^{r/2}\neq -1 \mod N]\geq 1-\frac{1}{2^m} \]
\eteorema

Para demostrarlo, necesitamos primero un lema previo.

\blema
\label{lemadivision}
 Sea $p$ un número primo diferente de 2 y sea $\alpha\in\mathbb{N}$. Sea $2^d$ la mayor potencia de $2$ que divide a $\varphi(p^\alpha)$. Entonces, con probabilidad de un medio $2^d$ divide al orden de cualquier elemento de $(\mathbb{Z}/p^\alpha\mathbb{Z})^*$.
\elema

\begin{proof}
	Por ser $p\neq 2$, entonces es impar, y por tanto $\varphi(p^\alpha) = p^{\alpha - 1}(p-1)$ es par. Esto implica que $d \geq 1$. Ya que el grupo $(\mathbb{Z}/p^\alpha\mathbb{Z})^*$ es cíclico, cualquier elemento se escribirá de la forma $g^k$, con $g$ el generador del grupo y $1\leq k \leq \varphi(p^\alpha)$. Sea $r$ el orden de dicho elemento.
	\begin{itemize}
		\item Si es $k$ impar, ya que $\left(g^k\right)^r = g^{kr} = 1 \mod p^\alpha$ entonces por el Teorema de Lagrange debe ser $\phi(p^\alpha)|kr$. De aquí, $2^d$ divide a $kr$, y por ser $k$ impar, necesariamente $2^d$ divide a $r$, el orden del elemento.
		\item Si es $k$ par, entonces
		\[ g^{\frac{k}{2}\varphi(p^\alpha)} = \left( g^{\varphi(p^\alpha)} \right)^{k/2} = 1^{k/2} = 1 \mod p^\alpha \]
		Como $r$ es el orden del elemento $g^k$, entonces necesariamente $r|\varphi(p^\alpha)/2$. Ya que $2^{d-1}$ es la mayor potencia de 2 que divide a $\varphi(p^\alpha)/2$, de aquí deducimos que $2^d$ no puede dividir a $r$.
	\end{itemize}
	Como exactamente la mitad de elementos de $(\mathbb{Z}/p^\alpha\mathbb{Z})^*$ se expresan con $k$ par y la mitad con $k$ impar, esto concluye la demostración.
\end{proof}

Ahora podemos demostrar el Teorema \ref{teoremaprob}.

\begin{proof}
	
	Probaremos que
	\[ P[r \mbox{ es impar ó } x^{r/2} = -1 \mod N] \leq \frac{1}{2^m} \]
	
	Por el Teorema Chino de los Restos, elegir un elemento $x$ aleatoriamente de $(\mathbb{Z}/N\mathbb{Z})^*$ es equivalente a elegir $x_j$ aleatoriamente de $(\mathbb{Z}/p_j^{\alpha_j}\mathbb{Z})^*$, para $j=1,\dots,m$ tales que $x = x_j \mod p_j^{\alpha_j}$. Sea $r_j$ el orden de $x_j$ en $(\mathbb{Z}/p_j^{\alpha_j}\mathbb{Z})^*$, $r$ el orden de $x$ en $(\mathbb{Z}/N\mathbb{Z})^*$, $2^{d}$ la mayor potencia de $2$ que divide a $r$ y $2^{d_j}$ la mayor potencia de $2$ que divide a $r_j$.
	\begin{itemize}
		\item Si es $r$ impar, entonces ya que $r_j|r$ para cada $j$ (porque $ x_j^r = x^r \mod p_j^{\alpha_j}$. Como $x^r = 1 \mod N$, entonces $x^r = 1 \mod p_j^{\alpha_j}$. Entonces, $x_j^r = 1 \mod p_j^{\alpha_j}$ y de aquí el orden $r_j|r$); si $r$ es impar entonces $r_j$ es impar, y de aquí, $d_j=0$ para todo $j$.
		\item Si $r$ es par y es $x^{r/2} = -1 \mod N$, entonces $x^{r/2} = -1 \mod p_j^{\alpha_j}$, esto es, $x_j^{r/2} = -1 \mod p_j^{\alpha_j}$. De aquí, $r_j \not| (r/2)$. Ya que $r_j | r$, necesariamente $d = d_j$ para cada $j$ (porque la mayor potencia de 2 que divide a $r_j$ será exactamente $2^d$, no puede ser menor porque $r_j \not| (r/2)$).
	\end{itemize}

	En definitiva, hemos probado que si $r$ es impar ó $x^{r/2} = -1 \mod N$, entonces $d_j$ toma el mismo valor para cada $j$. Esto implica que cada $d_j$ debe dividir (o no dividir) a cada $r_j$ simultáneamente. Por el Lema \ref{lemadivision}, la probabilidad de que esto ocurra es \[ \frac{1}{2} \cdot \frac{1}{2} \cdots \frac{1}{2} = \frac{1}{2^m} \] Por contención de sucesos, finalmente
	\[ P[r \mbox{ es impar ó } x^{r/2} = -1 \mod N] \leq P[d_j=k \mbox{ para cada } j] \leq P[ d_j|r_j \mbox{ ó } d_j \not| r_j \mbox{ para cada } j ] = \frac{1}{2^m} \]
\end{proof}

Una consecuencia inmediata del Teorema \ref{teoremaprob} es que si el número que queremos factorizar $N$ tiene 2 factores primos (como suele usarse en criptografía, como es el caso del algoritmo RSA), entonces tenemos la garantía de que usando el procedimiento descrito anteriormente, daremos al menos un 75\% de las veces con un elemento $y$ que nos permita hallar los factores de $N$ usando la Proposición \ref{prop1}. Un resumen de un algoritmo para factorizar sería el siguiente:
\begin{enumerate}
	\item Si $N$ es par, devolver el factor 2.
	\item Elegir aleatoriamente $y$ entre $2$ y $N-2$. Si $\mcd(y,N)>1$, devolver el factor $\mcd(y,N)$.
	\item Encontrar el orden $r$ del elemento $y$ módulo $N$.
	\item Si $r$ es par y $x^{r/2} \neq -1 \mod N$, entonces calcular $\mcd(x^{r/2} - 1, N)$ y $\mcd(x^{r/2}+1,N)$, comprobar cuál de ellos es un factor no trivial y devolver dicho factor. En caso contrario, volver al paso 2.
\end{enumerate}

Gracias al algoritmo de Euclides y la exponenciación modular, todos los pasos de este algoritmo se pueden ejecutar en tiempo polinomial excepto el paso $3$. Este problema se conoce como el problema de encontrar el orden, y no existe ningún método eficiente para resolverlo en un ordenador clásico. Sin embargo, usando la computación cuántica, sí es posible resolver este problema eficientemente. En realidad, el algoritmo descrito es un esquema del algoritmo de Shor, con la salvedad de que el paso $3$ se resuelve con un circuito cuántico, se obtienen los resultados y se prosigue en un ordenador clásico para culminar con la obtención del factor. Veremos cómo se construye este circuito en un ordenador cuántico y por qué funciona.

\section{Computación cuántica}
\subsection{Bits y qubits}
Ahora que hemos visto la motivación por la que necesitamos un ordenador cuántico, trataremos de describir cómo funciona. En el corazón de la computación clásica se encuentra el concepto de \textit{bit}, la unidad mínima de información que describe un sistema clásico 2-dimensional. Matemáticamente, podemos modelar un bit como un elemento de $\mathbb{Z}_2=\{0,1\}$, y $n$ bits como un elemento de $\Z_2^n$, donde la coordenada $i$-ésima representa el valor del bit $i$-ésimo. De este concepto surgen las \textit{puertas lógicas}, mecanismos que convierten un conjunto de bits en otro. Matemáticamente, estas puertas lógicas se modelan como funciones $f : \Z_2^n \to \Z_2^m$.

\begin{ejemplo}
	La puerta lógica AND implementa la operación lógica de conjunción (\&) y se define de esta manera:
	\[ f : \Z_2^2 \to \Z_2 \]
	\[ (0,0) \longmapsto 0 \]
	\[ (0,1) \longmapsto 0 \]
	\[ (1,0) \longmapsto 0 \]
	\[ (1,1) \longmapsto 1 \]
\end{ejemplo}

La computación cuántica surge como una generalización de estos conceptos. De igual manera que en la computación clásica, en la computación cuántica se encuentra el concepto de \textit{qubit}.

\bdefinicion
	Un \textit{qubit} es la unidad mínima de información describiendo un sistema cuántico 2-dimensional.
\edefinicion

Un qubit se modela como un elemento del espacio de Hilbert $\C^2$. Como ya vimos, este es un espacio vectorial y posee una base ortonormal $\{e_1,e_2\}$ (por ejemplo, la canónica: $\{ (0,1),(1,0) \}$). Así, todo qubit puede expresarse como una combinación $\C$-lineal de los elementos de la base. En el contexto de la computación cuántica, a estos elementos es usual denotarlos usando la notación de Dirac de esta manera:
\[ \ket{0} = e_1 \]
\[ \ket{1} = e_2 \]

y se denominan los \textit{estados básicos}. Con lo que cualquier qubit puede expresarse de la forma $ c_1\ket{0}+c_2\ket{1} $, $c_1,c_2\in\C$. Una restricción importante que se impone sobre los qubits es que para todo qubit $x\in\C^2$, $\|x\|^2 = |c_1|^2+|c_2|^2 = 1$ (lo cual ocurre si y sólo si $\| x \| = 1$, ver ejemplo \ref{normac2}). Así, cuando $c_1=1$ y $c_2=0$ se dice que el qubit está en el estado básico $0$ y al contrario, en el estado básico $1$. En cualquier otra situación, el qubit se dice que está en estado de \textit{superposición}. \\

Los qubits pueden ser, en cualquier momento, ``observados''. Esto saca al qubit de su estado de superposición, y hace que se comporte como un bit clásico, tomando el valor $0$ o el valor $1$ de manera aleatoria. La probabilidad con la que toma cada valor viene dado por las coordenadas del qubit: así, un qubit $c_1\ket{0}+c_2\ket{1}$ tiene una probabilidad $|c_1|$ de valer $0$ al ser observado, y $|c_2|$ de valer $1$ (de aquí la imposición anterior de que $|c_1|^2+|c_2|^2 = 1$). \\

Varios qubits se modelan matemáticamente usando el producto tensorial $(\C^2)^{\otimes n}$, donde $n$ es el número de qubits. Así, 2 qubits se expresan de la forma $ x = c_{00} \ket{0}\otimes\ket{0} + c_{01} \ket{0}\otimes\ket{1} +c_{01} \ket{1}\otimes\ket{0} + c_{11} \ket{1}\otimes\ket{1}$, $c_{00},c_{01},c_{10},c_{11} \in \C$. En general, $n$ qubits se expresan con $2^n$ coordenadas (pues la dimensión del producto tensorial de dos espacios vectoriales de dimensión $m$ y $n$ es $mn$). En la notación de Dirac es usual simplificar la notación del producto tensorial escribiendo simplemente $\ket{x}\otimes\ket{y} = \ket{x}\ket{y} = \ket{xy}$. En particular, cuando denotemos productos tensoriales de estados básicos, se escribirá $\ket{i_1}\ket{i_2} = \ket{i_1i_2}$, $i_1,i_2 \in \{ 0,1 \}$. \\

La observación de varios qubits es análoga a la situación anterior. Por ejemplo, para 2 qubits, tendríamos que hay una probabilidad $|c_{00}|$ de medir un 0 en el primer qubit y un 0 en el segundo, una probabilidad $|c_{10}|$ de medir un 1 en el primero y un 0 en el segundo, y así sucesivamente. Sin embargo, hay que justificar que estas probabilidades efectivamente suman 1.

\bproposicion
\label{qubitmodulo}
Sean $\ket{x_1},\dots,\ket{x_n}$ $n$ qubits, con $\ket{x_i} = x_0^{(i)}\ket{0} + x_1^{(i)}\ket{1}$. Entonces, $ \ket{x_1x_2\cdots x_n} $ verifica que  \[ \| \ket{x_1x_2\cdots x_n} \|^2 = \left\| \sum_{i_1,\dots,i_n\in\{0,1\}} \left( \left(\prod_{j=1}^n x_{i_j}^{(j)} \right) \ket{i_1i_2\cdots i_n} \right) \right\|^2 = 1  \]
\eproposicion
\begin{proof}
	Lo demostraremos por inducción. Para $n=1$ el resultado se tiene por definición de qubit.
	
	Supongamos el resultado cierto para $n=k$, y denotemos por simplicidad
	
	\[ \ket{x_1\dots x_k} = \alpha_0\ket{00\cdots 0}+\alpha_1\ket{00\cdots1}+\cdots+\alpha_{2^k-1}\ket{11\cdots 1} \]
	
	Entonces, si $ \ket{x_{k+1}} = \beta_0\ket{0}+\beta_1\ket{1} $,
	
	\begin{multline*} \ket{x_1\dots x_k}\ket{x_{k+1}} = \beta_0(\alpha_0\ket{00\cdots 00}+\alpha_1\ket{00\cdots10}+\cdots+\alpha_{2^k-1}\ket{11\cdots 10}) + \\
	+\beta_1(\alpha_0\ket{00\cdots 01}+\alpha_1\ket{00\cdots11}+\cdots+\alpha_{2^k-1}\ket{11\cdots 11}) \end{multline*}
	
	Por tanto sacando factor común,
	\[ \| \ket{x_1\dots x_{k+1}} \|^2 = |\beta_0|^2\left(\sum_{j=0}^{2^k-1} |\alpha_j|^2 \right) + |\beta_1|^2 \left(\sum_{j=0}^{2^k-1} |\alpha_j|^2 \right) \]
	
	Por hipótesis de inducción, $ (\sum_{j=0}^{2^k-1} |\alpha_j|^2) = 1 $ y además $|\beta_0|^2+|\beta_1|^2=1$ por ser $\ket{x_{k+1}}$ qubit, así,
	
	\[ \| \ket{x_1\dots x_{k+1}} \|^2 = |\beta_0|^2 + |\beta_1|^2 = 1 \]
\end{proof}

\subsection{Puertas cuánticas y circuitos cuánticos}

Una vez que hemos definido el concepto de qubit y cómo se modelan matemáticamente, el siguiente paso es definir el concepto de puerta cuántica; que no es más que una función $f: \C^{\otimes 2n} \to \C^{\otimes 2n}$ (envía $n$ qubits a $n$ qubits). Ya que, como vimos, estos dos espacios son espacios vectoriales, podemos tratar $f$ como una aplicación lineal. Además, ya que $f$ debe enviar qubits a qubits, debe verificarse para todo $x \in \C^{\otimes 2n}$, que
\[ \| f(x) \| = \| x \| = 1 \]

Y según vimos en el capítulo anterior, esto se logra si y sólo si $f$ es unitaria. Esta condición implica que el operador dado por $A^\dagger$ es la inversa de $A$. Es decir, toda puerta cuántica debe ser reversible (biyectiva), y su inversa está dada por la matriz $A^\dagger$. Es por ello que toda puerta cuántica debe tener exactamente los mismos qubits de entrada y de salida.
\begin{ejemplo}
	Las puertas cuánticas generalizan las puertas clásicas. Por ejemplo, la puerta $ NOT: \C^2\otimes \C^2 \to \C^2\otimes \C^2 $ es aquella puerta cuya matriz asociada es
	\[ \left( \begin{array}{cc} 0 & 1 \\ 1 & 0  \end{array} \right) \]
	
	Este operador es unitario, puesto que
	\[ AA^{\dagger} = \left( \begin{array}{cc} 0 & 1 \\ 1 & 0  \end{array} \right)\left( \begin{array}{cc} 0 & 1 \\ 1 & 0  \end{array} \right) = \left( \begin{array}{cc} 1 & 0 \\ 0 & 1 \end{array} \right) = Id \]
	
	Además, verifica que \[ NOT\ket{0} = \left( \begin{array}{cc} 0 & 1 \\ 1 & 0  \end{array} \right) \left( \begin{array}{c} 1 \\ 0  \end{array} \right) = \left( \begin{array}{c} 0 \\ 1  \end{array} \right) = \ket{1} \]
	\[ NOT\ket{1} = \left( \begin{array}{cc} 0 & 1 \\ 1 & 0  \end{array} \right) \left( \begin{array}{c} 0 \\ 1  \end{array} \right) = \left( \begin{array}{c} 1 \\ 0  \end{array} \right) = \ket{0} \]
\end{ejemplo}

\begin{ejemplo}
	Un ejemplo importante en la computación cuántica es el operador de Hadamard, aquel dado por la matriz
	\[ H = \frac{1}{\sqrt{2}}\left( \begin{array}{cc} 1 & 1 \\ 1 & -1 \end{array} \right) \]
	
	No es difícil ver que este operador es unitario y que verifica las siguientes identidades:
	
	\[ H\ket{0} = \frac{1}{\sqrt{2}}\ket{0}+\frac{1}{\sqrt{2}}\ket{1} \]
	\[ H\ket{1} = \frac{1}{\sqrt{2}}\ket{0}-\frac{1}{\sqrt{2}}\ket{1} \]
	
	\[ H\left( \frac{1}{\sqrt{2}}\ket{0}+\frac{1}{\sqrt{2}}\ket{1} \right)=\ket{0} \]
	\[ H\left( \frac{1}{\sqrt{2}}\ket{0}-\frac{1}{\sqrt{2}}\ket{1} \right)=\ket{1} \]
	
	Este operador será sumamente útil, porque nos permite convertir qubits en estados básicos a qubits en estados de superposición equiprobables (50\% de medir $0$, 50\% de medir $1$) y viceversa.	
\end{ejemplo}

Una sucesión de puertas cuánticas actuando sobre un conjunto de qubits forma un circuito. Para describir fácilmente circuitos que implementen algoritmos cuánticos, es común representarlos usando esquemas. Una puerta cuántica $A$ actuando sobre un qubit se representa de esta manera:
	\begin{figure}[h]
		\centering
		\includegraphics[height=40px]{images/quantum1.png}
	\end{figure}

Normalmente, por convenio se supone que la computación ocurre de izquierda a derecha. De esta manera, el circuito \clearpage
	\begin{figure}[h]
		\centering
		\includegraphics[height=40px]{images/quantum2.png}
	\end{figure}
indica la operación de aplicar $A$ y luego $B$ sobre un qubit $\ket{x}$, es decir,  $B(A(x))$. Estas dos operaciones se dice que son \textit{secuenciales}, porque ocurre una después de la otra. Notemos que podríamos haber simplificado este circuito calculando el operador $C = B\circ A$, cuya matriz asociada viene dada de multiplicar $BA$, las matrices asociadas de $B$ y de $A$, y reescribiendo el circuito con un solo operador actuando sobre $\ket{x}$, $C$.

Cuando tengamos un operador tenga más de un qubit de entrada o salida, en lugar de escribir muchas líneas, lo denotamos de esta manera:

	\begin{figure}[h]
	\centering
	\includegraphics[height=40px]{images/quantum3.png}
\end{figure}

En este caso, $A$ sería un operador que trabaja sobre $n$ qubits (observemos que hubiese sido equivalente haber dibujado $n$ líneas entrando y saliendo de $A$).

En un circuito cuántico, también pueden ocurrir operaciones \textit{en paralelo} sobre varios qubits. Por ejemplo:
	\begin{figure}[h]
	\centering
	\includegraphics[height=85px]{images/quantum4.png}
\end{figure}

Si $\ket{x}$,$\ket{y}$ son $n$ y $m$ qubits respectivamente, Entonces este circuito aplica, sobre la entrada $\ket{x}\otimes\ket{y}$, la operación $A\ket{x} \otimes B\ket{y}$. Este circuito podría simplificarse calculando el operador $C = A\otimes B$ (ver apéndice), cuya entrada son $n+m$ qubits, de manera que la acción del circuito podría escribirse como $C(\ket{x}\otimes\ket{y}) = (A \otimes B) (\ket{x}\otimes \ket{y})$.

\begin{ejemplo}
	El operador de Hadamard $H$ aplicado sobre varios qubits se comporta como sigue. Dados $n$ qubits $\ket{x_1\cdots x_n}$ en estado básico $0$, entonces el resultado de aplicar el operador $H$ a cada uno de ellos en paralelo es:
	
	$H\ket{x_1}\otimes H\ket{x_2} \otimes \cdots \otimes H\ket{x_n}$ = $ H\ket{0} \otimes H\ket{0} \otimes \cdots \otimes H\ket{x_n} = \left(\frac{1}{\sqrt{2}}\ket{0}+\frac{1}{\sqrt{2}}\ket{1} \right) \otimes \dots \otimes \left( \frac{1}{\sqrt{2}}\ket{0}+\frac{1}{\sqrt{2}}\ket{1} \right) = \frac{1}{\sqrt{2}^n} \sum_{i_1,\dots,i_n\in\{0,1\}}\ket{i_1\cdots i_n} $.
	
	Por simplicidad, este operador se denota $H^{\otimes n}$, y su matriz asociada es $\frac{1}{\sqrt{2}^n} H_{2^n}$, donde $H_{2^n}$ es la matriz de Hadamard de orden $2^n$ \textbf{(añadir referencia)}.
\end{ejemplo}

Una puerta especial es la de \textit{medición}. Cuando se coloca al final de uno o varios qubits, pasan de ser un bits cuánticos a bits clásicos siguiendo la ley de probabilidad explicada anteriormente. En el siguiente ejemplo, se medirían simultáneamente $n$ qubits tras aplicarles un operador $A$:

	\begin{figure}[h]
	\centering
	\includegraphics[height=40px]{images/quantum5.png}
\end{figure}

Un caso interesante es cuando se miden qubits parcialmente, por ejemplo, usando este circuito:
	\begin{figure}[h]
	\centering
	\includegraphics[height=40px]{images/quantum6v2.png}
\end{figure}

Donde, obviamente, $a+b = n$. En este caso, el estado de $\ket{x}$ justo después de aplicarse $A$ es $A(\ket{x})$. Sin embargo, después se observan los últimos $b$ qubits de $A(\ket{x})$; ¿cuál será entonces la entrada de $B$, que se aplica sobre los restantes $a$ qubits, que no fueron observados?

Denotemos la salida de $A$ como
\[ \ket{x_1} = \ket{y_1}\ket{z_1} = \sum_{i=0}^{2^a-1}\sum_{j=0}^{2^b-1} \alpha_{ij} \ket{ij} \]

Si tras medir $\ket{z_1}$ observamos el estado $ \ket{k} $, $k\in [0,2^b-1]$ (el cual ocurrirá con probabilidad $ \sum_{i=0}^{2^a - 1} |\alpha_{ik}|^2 $), entonces parece lógico que el estado final del sistema tras medir los últimos $b$ qubits sea

\[ \ket{y} = \sum_{i=0}^{2^a - 1} \alpha_{ik}\ket{ik} \]

Sin embargo, el módulo de este qubit no es necesariamente 1 (en general, $\ket{y}$ no es el producto tensorial de varios qubits). Por eso, es necesario \textit{renormalizar} el qubit:

\[ \ket{y} = \frac{\sum_{i=0}^{2^a - 1} \alpha_{ik}\ket{ik}}{\sqrt{\sum_{i=0}^{2^a -1} |\alpha_{ik}|^2}}  \]

Puesto que ahora los últimos $b$ qubits son siempre constantes y valen $k$, podemos ignorarlos, ya que ahora se comportan como bits clásicos, y finalmente nos queda que la entrada de $B$ es:

\[ \ket{y} = \frac{\sum_{i=0}^{2^a - 1} \alpha_{ik}\ket{i}}{\sqrt{\sum_{i=0}^{2^a -1} |\alpha_{ik}|^2}} \]

La justificación formal de estas ideas intuitivas se apoya en la teoría de operadores de medida (ver \cite{quantuminformation}).

\begin{ejemplo}
Con la notación anterior, si $\alpha_{ik}=\frac{1}{\sqrt{2^n}}$ para $n$ amplitudes y valen 0 $0$ en las demás, entonces

\[ \ket{y} = \frac{\frac{1}{\sqrt{2^n}}\sum_i \ket{i}}{\sqrt{\sum_i \left|\frac{1}{\sqrt{2^n}}\right|^2}} = \frac{\sum_i \ket{i}}{\sqrt{n}} \]

Es decir, el resultado de medir un subconjunto de un conjunto de qubits en estado de superposición equiprobable, es otro estado de superposición equiprobable, cuya expresión es la suma de todos los posibles estados de los qubits no medidos y con amplitudes el inverso de la raíz cuadrada del número de estados posibles.

\end{ejemplo}



\subsection{El circuito para encontrar el orden}

Con estas nociones básicas, finalmente podemos presentar el circuito para resolver el problema de encontrar el orden. Algunos detalles formales se omitirán, por ejemplo, cómo se calcula el orden si resulta que es impar (recordemos que aunque es un caso en el cual no podemos calcular los factores, debemos ser capaces de calcularlo para poder descartarlo y elegir otro elemento).

Para ello, necesitamos dos puertas cuánticas. Una de ellas es la \textit{transformada cuántica de Fourier}. Esta transformación actúa sobre los estados básicos $\ket{0},\cdots,\ket{N-1}$ (por ejemplo, en 2 qubits, $N=4$) de la siguiente forma: para cada $0\leq j \leq N-1$
\[ \ket{j} \mapsto \frac{1}{\sqrt{N}}\sum_{k=0}^{N-1}e^{2\pi ijk/N}\ket{k} \]

La definición de la transformada cuántica de Fourier (abreviadamente, \textit{QFT}, de \textit{Quantum Fourier Transform}) sobre un qubit se extiende por linealidad. Para que sea una puerta cuántica, debe ser un operador unitario.

\bproposicion
La transformada cuántica de Fourier es un operador unitario.
\eproposicion
\begin{proof}
	Denotemos $A = (a_{jk})$, $ k,j\in\{0,\cdots,N-1\} $ la matriz asociada de $QFT$ respecto de la base común de los espacios de llegada y salida $\{\ket{0},\dots,\ket{N-1} \}$. Entonces, denotando $\pi^j$ la proyección sobre $\ket{j}$: 
	
	\[ a_{jk} = \pi^j(QFT(\ket{k})) = \frac{1}{\sqrt{N}}e^{2\pi i j k / N} \]
	
	Por otro lado, denotando $A^{\dagger} = (b_{jk})$, $ k,j\in\{0,\cdots,N-1\} $, entonces:
	
	\[ b_{jk} = \overline{a_{kj}} = \frac{1}{\sqrt{N}}\overline{e^{2\pi i j k / N}} = \frac{1}{\sqrt{N}}e^{-2\pi i j k / N}  \]
	
	Veamos que $A^{\dagger}A = I$. Denotemos $c_{kj}$ las entradas de la matriz $ A^{\dagger}A $.
	\begin{itemize}
		\item Si $k=j$, entonces:
		\[ c_{kk} = \sum_{j=0}^{N-1}b_{kj}a_{jk} = \sum_{j=0}^{N-1} \left( \frac{1}{\sqrt{N}}e^{-2\pi i k j / N} \right)\left( \frac{1}{\sqrt{N}}e^{2\pi i j k / N} \right) = \sum_{j=0}^{N-1}\frac{1}{N} = N\frac{1}{N} = 1 \]
		\item Si $k\neq j$, entonces $k-j \in \Z\setminus\{0\}$. Por tanto,
		\begin{multline*} c_{kl} = \sum_{j=0}^{N-1}b_{lj}a_{jk} = \left( \frac{1}{\sqrt{N}}e^{-2\pi i l j / N} \right)\left( \frac{1}{\sqrt{N}}e^{2\pi i j k / N} \right) = \\ = \frac{1}{N}\sum_{j=0}^{N-1}e^{\frac{2\pi ij}{N}(k-l)} = \frac{1}{N}\frac{1-\left( e^{\frac{2\pi ij}{N}(k-l)} \right)^N }{1-e^{\frac{2\pi i}{N}(k-l)}} \end{multline*}
		
		Puesto que $k-l\in \Z$, $ \left( e^{\frac{2\pi ij}{N}(k-l)} \right)^N = e^{2\pi ij(k-l)} = 1  $
		y esto implica que $c_{kl}=0$.
		
	\end{itemize}

	Así pues, como $c_{kj} = \left\{ \begin{array}{l} 1 \mbox{ si } k=j \\ 0 \mbox{ si } k\neq j \end{array} \right.$ $A^\dagger A = I$, como queríamos demostrar.
	
\end{proof}


%\begin{figure}[h]
%	\centering
%	\includegraphics[height=40px]{images/quantum7.png}
%\end{figure}