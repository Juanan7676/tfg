
\chapter{Algoritmos de criptografía poscuántica}
\label{cha:segunda}

En esta sección presentamos varias propuestas, tanto de criptosistemas como de sistemas de firma, que se cree que resisten a los ordenadores cuánticos. La idea para desarrollar sistemas de clave pública es considerar problemas difíciles, es decir, problemas en los que no existan algoritmos clásicos ni cuánticos eficientes que los resuelvan. Hasta la aparición de los ordenadores cuánticos, los dos problemas más utilizados eran el problema de la factorización de números enteros (base del criptosistema y sistema de firma \textit{RSA}) y el problema del logaritmo discreto (base de los sistemas de firma \textit{DSA} y \textit{ECDSA}). Sin embargo, al haberse encontrado algoritmos eficientes que los resuelven en ordenadores cuánticos, estos sistemas quedarán obsoletos cuando la computación cuántica sea una realidad.

 Nuestro estudio se centrará en aquellos sistemas basados en funciones hash y aquellos basados en códigos autocorrectores. Estos se basan en dos problemas fundamentales: encontrar la preimagen de una función de un solo sentido (criptografía basada en funciones hash) y el problema de encontrar el síndrome de un código autocorrector (criptografía basada en códigos).

\section{Criptografía basada en funciones hash}

\subsection{Introducción a las funciones hash}

Como ya hemos comentado, este tipo de sistemas utlizan un tipo de función especial denominada \textit{hash}.

\bdefinicion
\label{familiahash}
	Una \textit{familia de funciones hash} es una 4-tupla $(\mathcal{X},\mathcal{Y},\mathcal{K},\mathcal{H})$, donde:
	\begin{enumerate}
		\item $\mathcal{X}$ es un conjunto de posibles \textit{mensajes}.
		\item $\mathcal{Y}$ es un conjunto finito de posibles \textit{resúmenes}.
		\item $\mathcal{K}$ es el \textit{espacio de claves}, un conjunto finito de posibles claves.
		\item Para cada $K\in\mathcal{K}$, existe una \textit{función hash} $h_K \in \mathcal{H}$, con $h_k : \mathcal{X} \to \mathcal{Y}$.
	\end{enumerate}
\edefinicion

Observemos que, mientras que $\mathcal{X}$ puede ser un conjunto infinito, $\mathcal{Y}$ debe ser finito.
\bdefinicion
Decimos que una pareja $(x,y)\in\mathcal{X}\times\mathcal{Y}$ es una \textit{pareja válida} sobre la clave $K$ si $h_K(x) = y$.
\edefinicion

El gran interés criptográfico en las funciones hash subyace en aquellas en las que sólo sea posible (o computacionalmente factible) calcular una pareja válida $(x,y)$ si se conoce $x$ de antemano, calculando $y=h_K(x)$.

La mayor parte de las funciones hash utilizadas no utilizan una clave $K \in \mathcal{K}$ para ser definidas. En la definición anterior, esto se corresponde a que $|\mathcal{K}|=1$, es decir, la familia tiene una única función hash. En este caso, podemos suprimir la clave en la definición de la función.

\bdefinicion
	Una \textit{función hash sin clave} es una función $h : \mathcal{X} \to \mathcal{Y}$, con $\mathcal{X}$ y $\mathcal{Y}$ definidas en la Definición \ref{familiahash}.
\edefinicion

En lo que sigue, trabajaremos con una función hash $h$ sin clave. Como hemos adelantado, nos interesa que $h$ verifique que sólo sea posible calcular una pareja válida $(x,y)$ conociendo $x$ de antemano. Más formalmente, nos interesa que sea difícil resolver estos problemas para $h$:

\bdefinicion
	Sea $h : \mathcal{X} \to \mathcal{Y}$ una función hash sin clave. Se dice que $h$ es \textit{resistente a la preimagen} si es difícil resolver el siguiente problema: dado $y \in \mathcal{Y}$, encontrar $x\in \mathcal{X}$ tal que $h(x) = y$.
\edefinicion

\bdefinicion
\label{2preimage}
Sea $h : \mathcal{X} \to \mathcal{Y}$ una función hash sin clave. Se dice que $h$ es \textit{resistente a la segunda preimagen} si es difícil resolver el siguiente problema: dado $x \in \mathcal{X}$, encontrar $x'\in\mathcal{X}$ tal que $x\neq x'$ pero $h(x')=h(x)$.
\edefinicion

\bdefinicion
\label{collision}
Sea $h : \mathcal{X} \to \mathcal{Y}$ una función hash sin clave. Se dice que $h$ es \textit{resistente a la colisión} si es difícil resolver el siguiente problema: encontrar $x,x'\in X$ con $x\neq x'$ tales que $h(x)=h(x')$.
\edefinicion

Es importante observar la sutil diferencia entre la Definición \ref{2preimage} y la Definición \ref{collision}: mientras que en la primera tenemos un valor $x$ fijado de antemano, en el segundo no. De hecho, la resistencia a la colisión implica la resistencia a la segunda preimagen, pero el recíproco no es cierto en general \cite{hashfunctions}.

Hay funciones que cumplen con estos criterios, es decir, que no se han encontrado algoritmos que resuelvan ninguno de los tres problemas de forma eficiente. Un buen ejemplo de ello es el \textit{SHA} o \textit{Secure Hash Algorithm}, en sus versiones más modernas (\textit{SHA-256}, \textit{SHA-384}, \textit{SHA-512}) \cite{sha256security}. Para otras versiones más antiguas, sin embargo, como el \textit{SHA-1}, se han encontrado ataques que producen colisiones \cite{sha256collisions}.

\subsection{Un esquema de firma: el esquema de un solo uso de Lamport-Diffie (LD-OTS)}

Presentamos en esta sección el esquema de firma de un solo uso de Lamport-Diffie (LD-OTS). La seguridad de este esquema depende de la propiedad de resistencia a la segunda preimagen de la función hash utilizada. Además, necesita una función resistente a la preimagen. En caso de que la función hash utilizada posea también esta propiedad, es posible usar la misma función en las dos partes del algoritmo.

\begin{framed}
	\begin{center}
	\textbf{Esquema de firma de Lamport-Diffie} \\
	\end{center}
	
	\textbf{Parámetros:} Un número natural $n$, el número de bits de la función hash usada, y dos funciones $ f : \{0,1\}^n \to \{0,1\}^n $ y $ H : \{0,1\}^* \to \{0,1\}^n $, siendo $f$ una función resistente a la preimagen y $H$ una función hash. \\
	
	\textbf{Generación de claves:} Se elige una clave privada $X$ con $2n$ números de $n$ bits elegidos aleatoriamente de manera uniforme, de manera que
	\[ X = \left(x_{n-1}[0],x_{n-1}[1],\cdots,x_1[0],x_1[1],x_0[0],x_0[1] \right) \]
	
	La clave pública $Y$ se calcula evaluando cada coordenada mediante $f$, es decir,
	\[ Y = \left(y_{n-1}[0],y_{n-1}[1],\cdots,y_1[0],y_1[1],y_0[0],y_0[1] \right) \]
	donde $y_i[j] = f(x_i[j])$, $0\leq i \leq n-1$, $j=0,1$. \\
	
	\textbf{Proceso de firma:} Para firmar un documento $M\in\{0,1\}^*$, se calcula $H(M) = (d_{n-1},\dots,d_1,d_0)$, y la firma del documento es
	\[ \sigma = \left( x_{n-1}[d_{n-1}],\dots,x_1[d_1],x_0[d_0] \right) \] 
	
	\textbf{Proceso de verificación}: Para verificar un mensaje firmado $(M,\sigma)$ con una clave pública $Y$, se calcula $H(M)=(d_{n-1},\dots,d_1,d_0)$ y se comprueba que para cada $j=0,\dots,n-1$:
	\[ f(\sigma_{j}) = y_j[d_j] \]
	
\end{framed}


\begin{figure}
\centering
\makebox[\textwidth]{
\includegraphics[width=1.3\textwidth]{images/lamport.png}}
\caption{Esquema del proceso de firma en el esquema LD-OTS. La verificación se hace calculando la función hash del mensaje firmado, y comprobando que el hash de cada elemento de la firma coincide con la clave pública en cada bit del hash del mensaje firmado. Imagen de Ignacio Zelaya, bajo licencia \href{https://creativecommons.org/licenses/by-sa/4.0/deed.en}{Creative Commons Attribution-Share Alike 4.0 International}.}
\end{figure}

La seguridad de este esquema radica en la resistencia a la preimagen y las características de la función hash utilizada. En efecto, un atacante Óscar quisiera firmar un documento $M'$ distinto a $M$, debería proceder de la siguiente manera:
\begin{enumerate}
	\item Calcular $H(M') = (d_{n-1}',d_{n-2}',\dots,d_1',d_0')$.
	\item Hallar unos elementos $x_j$, $j=0,\dots,n-1$ tales que
		\[ f(x_j) = y_j[d_{j}'] \]
	\item Firmar con $\sigma = (x_j)_{j=0,\dots,n-1}$.
\end{enumerate}

Para aquellos $j$ en los que $d_j=d_j'$, Óscar puede elegir $x_j := \sigma_j$ de la firma del documento $M$ que Alice proporcionó. Pero para los otros casos, la propiedad de resistencia a la preimagen de $f$ hace que para Óscar sea computacionalmente infactible hallar dichos elementos. Por tanto, su única opción sería encontrar $M'$ tal que $H(M)=H(M')$, de manera que $d_j=d_j'$ para todo $j=0,\dots,n-1$. Pero la propiedad de resistencia a la segunda preimagen de $H$ hace que hallar dicho $M'$ sea computacionalmente infactible para Óscar. \\

Mediante este ejemplo es sencillo ver por qué este esquema solo debe usarse una vez para cada par de claves. Si Alice emitiera dos documentos firmados $(M,\sigma)$ y $(M',\sigma')$ distintos con el mismo par de claves privada y pública $(X,Y)$, entonces se harían públicos
\[ \sigma = ( x_{n-1}[d_{n-1}], \dots, x_1[d_1],x_0[d_0] ) \]
\[ \sigma' = ( x_{n-1}[d_{n-1}'], \dots, x_1[d_1'],x_0[d_0'] ) \]

Entonces, ahora Óscar podría generar firmas de documentos cuyos hashes fuesen combinaciones de los hashes de $M$ y $M'$; por ejemplo $M''$ tal que
\[H(M'') = (d_{n-1},d_{n-2}',\dots,d_3',d_2,d_1',d_0) \] 
De hecho, si resultase que $d_j \neq d_j'$ para todo $j$, Óscar conocería la clave privada $X$ completa y podría firmar cualquier documento.



\section{Criptografía basada en códigos}

