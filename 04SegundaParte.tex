

\chapter{Algoritmos de criptografía poscuántica}
\label{cha:segunda}

En esta sección presentamos varias propuestas, tanto de criptosistemas como de sistemas de firma, que se cree que resisten a los ordenadores cuánticos. La idea para desarrollar sistemas de clave pública es considerar problemas difíciles, es decir, problemas en los que no existan algoritmos clásicos ni cuánticos eficientes que los resuelvan. Hasta la aparición de los ordenadores cuánticos, los dos problemas más utilizados eran el problema de la factorización de números enteros (base del criptosistema y sistema de firma \textit{RSA}) y el problema del logaritmo discreto (base de los sistemas de firma \textit{DSA} y \textit{ECDSA}). Sin embargo, al haberse encontrado algoritmos eficientes que los resuelven en ordenadores cuánticos, estos sistemas quedarán obsoletos cuando la computación cuántica sea una realidad.

 Nuestro estudio se centrará en aquellos sistemas basados en funciones hash y aquellos basados en códigos autocorrectores. Estos se basan en dos problemas fundamentales: encontrar la preimagen de una función de un solo sentido (criptografía basada en funciones hash) y el problema de encontrar el síndrome de un código autocorrector (criptografía basada en códigos).

\section{Criptografía basada en funciones hash}

\subsection{Introducción a las funciones hash}

Como ya hemos comentado, este tipo de sistemas utlizan un tipo de función especial denominada \textit{hash}.

\bdefinicion
\label{familiahash}
	Una \textit{familia de funciones hash} es una 4-tupla $(\mathcal{X},\mathcal{Y},\mathcal{K},\mathcal{H})$, donde:
	\begin{enumerate}
		\item $\mathcal{X}$ es un conjunto de posibles \textit{mensajes}.
		\item $\mathcal{Y}$ es un conjunto finito de posibles \textit{resúmenes}.
		\item $\mathcal{K}$ es el \textit{espacio de claves}, un conjunto finito de posibles claves.
		\item Para cada $K\in\mathcal{K}$, existe una \textit{función hash} $h_K \in \mathcal{H}$, con $h_k : \mathcal{X} \to \mathcal{Y}$.
	\end{enumerate}
\edefinicion

Observemos que, mientras que $\mathcal{X}$ puede ser un conjunto infinito, $\mathcal{Y}$ debe ser finito.
\bdefinicion
Decimos que una pareja $(x,y)\in\mathcal{X}\times\mathcal{Y}$ es una \textit{pareja válida} sobre la clave $K$ si $h_K(x) = y$.
\edefinicion

El gran interés criptográfico en las funciones hash subyace en aquellas en las que sólo sea posible (o computacionalmente factible) calcular una pareja válida $(x,y)$ si se conoce $x$ de antemano, calculando $y=h_K(x)$.

La mayor parte de las funciones hash utilizadas no utilizan una clave $K \in \mathcal{K}$ para ser definidas. En la definición anterior, esto se corresponde a que $|\mathcal{K}|=1$, es decir, la familia tiene una única función hash. En este caso, podemos suprimir la clave en la definición de la función.

\bdefinicion
	Una \textit{función hash sin clave} es una función $h : \mathcal{X} \to \mathcal{Y}$, con $\mathcal{X}$ y $\mathcal{Y}$ definidas en la Definición \ref{familiahash}.
\edefinicion

En lo que sigue, trabajaremos con una función hash $h$ sin clave. Como hemos adelantado, nos interesa que $h$ verifique que sólo sea posible calcular una pareja válida $(x,y)$ conociendo $x$ de antemano. Más formalmente, nos interesa que sea difícil resolver estos problemas para $h$:

\bdefinicion
	Sea $h : \mathcal{X} \to \mathcal{Y}$ una función hash sin clave. Se dice que $h$ es \textit{resistente a la preimagen} si es difícil resolver el siguiente problema: dado $y \in \mathcal{Y}$, encontrar $x\in \mathcal{X}$ tal que $h(x) = y$.
\edefinicion

\bdefinicion
\label{2preimage}
Sea $h : \mathcal{X} \to \mathcal{Y}$ una función hash sin clave. Se dice que $h$ es \textit{resistente a la segunda preimagen} si es difícil resolver el siguiente problema: dado $x \in \mathcal{X}$, encontrar $x'\in\mathcal{X}$ tal que $x\neq x'$ pero $h(x')=h(x)$.
\edefinicion

\bdefinicion
\label{collision}
Sea $h : \mathcal{X} \to \mathcal{Y}$ una función hash sin clave. Se dice que $h$ es \textit{resistente a la colisión} si es difícil resolver el siguiente problema: encontrar $x,x'\in X$ con $x\neq x'$ tales que $h(x)=h(x')$.
\edefinicion

Es importante observar la sutil diferencia entre la Definición \ref{2preimage} y la Definición \ref{collision}: mientras que en la primera tenemos un valor $x$ fijado de antemano, en el segundo no. De hecho, la resistencia a la colisión implica la resistencia a la segunda preimagen, pero el recíproco no es cierto en general \cite{hashfunctions}.

Hay funciones que cumplen con estos criterios, es decir, que no se han encontrado algoritmos que resuelvan ninguno de los tres problemas de forma eficiente. Un buen ejemplo de ello es el \textit{SHA} o \textit{Secure Hash Algorithm}, en sus versiones más modernas (\textit{SHA-256}, \textit{SHA-384}, \textit{SHA-512}) \cite{sha256security}. Para otras versiones más antiguas, sin embargo, como el \textit{SHA-1}, se han encontrado ataques que producen colisiones \cite{sha256collisions}.

\subsection{Un esquema de firma: el esquema de un solo uso de Lamport-Diffie (LD-OTS)}

Presentamos en esta sección el esquema de firma de un solo uso de Lamport-Diffie (LD-OTS). La seguridad de este esquema depende de la propiedad de resistencia a la segunda preimagen de la función hash utilizada. Además, necesita una función resistente a la preimagen. En caso de que la función hash utilizada posea también esta propiedad, es posible usar la misma función en las dos partes del algoritmo.

\begin{framed}
	\begin{center}
	\textbf{Esquema de firma de Lamport-Diffie} \\
	\end{center}
	
	\textbf{Parámetros:} Un número natural $n$, el número de bits de la función hash usada, y dos funciones $ f : \{0,1\}^n \to \{0,1\}^n $ y $ H : \{0,1\}^* \to \{0,1\}^n $, siendo $f$ una función resistente a la preimagen y $H$ una función hash. \\
	
	\textbf{Generación de claves:} Se elige una clave privada $X$ con $2n$ números de $n$ bits elegidos aleatoriamente de manera uniforme, de manera que
	\[ X = \left(x_{n-1}[0],x_{n-1}[1],\cdots,x_1[0],x_1[1],x_0[0],x_0[1] \right) \]
	
	La clave pública $Y$ se calcula evaluando cada coordenada mediante $f$, es decir,
	\[ Y = \left(y_{n-1}[0],y_{n-1}[1],\cdots,y_1[0],y_1[1],y_0[0],y_0[1] \right) \]
	donde $y_i[j] = f(x_i[j])$, $0\leq i \leq n-1$, $j=0,1$. \\
	
	\textbf{Proceso de firma:} Para firmar un documento $M\in\{0,1\}^*$, se calcula $H(M) = (d_{n-1},\dots,d_1,d_0)$, y la firma del documento es
	\[ \sigma = \left( x_{n-1}[d_{n-1}],\dots,x_1[d_1],x_0[d_0] \right) \] 
	
	\textbf{Proceso de verificación}: Para verificar un mensaje firmado $(M,\sigma)$ con una clave pública $Y$, se calcula $H(M)=(d_{n-1},\dots,d_1,d_0)$ y se comprueba que para cada $j=0,\dots,n-1$:
	\[ f(\sigma_{j}) = y_j[d_j] \]
	
\end{framed}


\begin{figure}
\centering
\makebox[\textwidth]{
\includegraphics[width=1.3\textwidth]{images/lamport.png}}
\caption{Esquema del proceso de firma en el esquema LD-OTS. La verificación se hace calculando la función hash del mensaje firmado, y comprobando que el hash de cada elemento de la firma coincide con la clave pública en cada bit del hash del mensaje firmado. Imagen de Ignacio Zelaya, bajo licencia \href{https://creativecommons.org/licenses/by-sa/4.0/deed.en}{Creative Commons Attribution-Share Alike 4.0 International}.}
\end{figure}

La seguridad de este esquema radica en la resistencia a la preimagen y las características de la función hash utilizada. En efecto, un atacante Óscar quisiera firmar un documento $M'$ distinto a $M$, debería proceder de la siguiente manera:
\begin{enumerate}
	\item Calcular $H(M') = (d_{n-1}',d_{n-2}',\dots,d_1',d_0')$.
	\item Hallar unos elementos $x_j$, $j=0,\dots,n-1$ tales que
		\[ f(x_j) = y_j[d_{j}'] \]
	\item Firmar con $\sigma = (x_j)_{j=0,\dots,n-1}$.
\end{enumerate}

Para aquellos $j$ en los que $d_j=d_j'$, Óscar puede elegir $x_j := \sigma_j$ de la firma del documento $M$ que Alice proporcionó. Pero para los otros casos, la propiedad de resistencia a la preimagen de $f$ hace que para Óscar sea computacionalmente infactible hallar dichos elementos. Por tanto, su única opción\footnote{Esta idea intuitiva ha de probarse formalmente. En la última parte de esta sección, probaremos que si existe un ataque contra este sistema, entonces podremos construir un algoritmo que encuentre colisiones de $H$. Por tanto, este sistema será seguro si la función hash subyacente es segura.} sería encontrar $M'$ tal que $H(M)=H(M')$, de manera que $d_j=d_j'$ para todo $j=0,\dots,n-1$. Pero la propiedad de resistencia a la segunda preimagen de $H$ hace que hallar dicho $M'$ sea computacionalmente infactible para Óscar. \\

Mediante este ejemplo es sencillo ver por qué este esquema solo debe usarse una vez para cada par de claves. Si Alice emitiera dos documentos firmados $(M,\sigma)$ y $(M',\sigma')$ distintos con el mismo par de claves privada y pública $(X,Y)$, entonces se harían públicos
\[ \sigma = ( x_{n-1}[d_{n-1}], \dots, x_1[d_1],x_0[d_0] ) \]
\[ \sigma' = ( x_{n-1}[d_{n-1}'], \dots, x_1[d_1'],x_0[d_0'] ) \]

Entonces, ahora Óscar podría generar firmas de documentos cuyos hashes fuesen combinaciones de los hashes de $M$ y $M'$; por ejemplo $M''$ tal que
\[H(M'') = (d_{n-1},d_{n-2}',\dots,d_3',d_2,d_1',d_0) \] 
De hecho, si resultase que $d_j \neq d_j'$ para todo $j$, Óscar conocería la clave privada $X$ completa y podría firmar cualquier documento.

\subsection{Experimento computacional: rompiendo el sistema LD-OTS con 2 firmas}

En este experimento, veremos cómo se puede atacar el sistema si Alice, en contra del protocolo, firma dos documentos diferentes con el mismo par de claves $(X,Y)$. Haremos una comparación entre un ataque de fuerza bruta y un ataque específico cuando se tienen dos firmas con una misma clave. \\

Supongamos, en primer lugar, que un atacante Óscar recibe un documento firmado $(M,\sigma)$ de Alice con una clave pública $Y$, y quiere emitir otro documento firmado $(M',\sigma')$ usando su clave pública. El algoritmo de búsqueda por fuerza bruta que ejecutaría Óscar sería el siguiente:

\balgoritmo
Búsqueda por fuerza bruta \\

\noindent
\textbf{Entrada:} Un conjunto de documentos posibles $S$, una clave pública $X$ y un documento firmado $(M,\sigma)$ tal que $M \notin S$. \\
\textbf{Salida:} Un documento firmado $(M',\sigma')$ con $M'\in S$, o \textit{error}. \\
\setlist{nolistsep}
\begin{enumerate}[noitemsep]
	\item Calcular $d := H(M)$.
	\item Para cada $M' \in S$ hacer:
	\begin{enumerate}
		\item Calcular $d' := H(M')$.
		\item \textbf{Si} $ d = d' $, \textbf{entonces devolver} $(M',\sigma)$.
	\end{enumerate}
	\item \textbf{Devolver} \textit{error}.
\end{enumerate}
\ealgoritmo

Evidentemente, cuanto más grande sea el conjunto $S$ de mensajes posibles, más probable es que el algoritmo dé con un documento firmado. Por contrario, cuanto más grande sea el parámetro $n$ del sistema de firma, menos probable es dar con un elemento cuyo hash coincida con el documento firmado original. \\

En la siguiente tabla se recogen la cantidad de documentos probados antes de dar con un documento firmado con la misma firma que el original para cada valor de $n$. Los detalles de la implementación en Python se pueden consultar en el último apéndice de este trabajo; para las funciones $f$ y $H$ se ha usado la función \textit{SHA-256} truncada a los primeros $n$ bits deseados en cada caso.

\begin{center}
\begin{threeparttable}
\begin{tabular}{|c|c|c|}
	\hline
	$n$ & Número de documentos & Tiempo \\
	\hline
	8 & $64$ & $0.0021$ segundos \\
	\hline
	16 & $10.350$ & $0.1206$ segundos \\
	\hline
	24\tnote{1} & $>30.233.088$ & $ >6.1 $ minutos \\
	\hline
	32\tnote{1} & $>30.233.088$ & $ >6.1 $ minutos \\
	\hline
	
\end{tabular}
\begin{tablenotes}
	\item[1] El algoritmo no fue capaz de producir un documento firmado falsificado.
\end{tablenotes}
\end{threeparttable}
\end{center}

Como podemos ver, la complejidad del problema escala extremadamente rápido conforme aumenta el valor de $n$. Sin embargo, si Alice firmase dos documentos distintos, entonces Óscar podría abordar este problema de manera ligeramente distinta, pues no solo le valdría encontrar un documento cuyo hash sea el de alguno de los dos documentos que ha firmado Alice; podría hacer combinaciones de ellos.

\balgoritmo
Búsqueda con dos documentos firmados \\

\noindent
\textbf{Entrada:} Un conjunto de documentos posibles $S$, una clave pública $X$ y dos documentos firmados $(M,\sigma),(M',\sigma')$ con $M\neq M'$, tales que $M,M'\notin S$. \\
\textbf{Salida:} Un documento firmado $(M'',\sigma'')$ con $M''\in S$, o \textit{error}. \\
\setlist{nolistsep}
\begin{enumerate}[noitemsep]
	\item Calcular $d := H(M)$ y $d' := H(M')$.
	\item Para cada $M'' \in S$ hacer:
	\begin{enumerate}
		\item Calcular $d'' := H(M')$.
		\item Poner $\sigma'' := ()$ (una lista vacía).
		\item Para cada $j=0,\dots,n-1$ hacer:
		\begin{enumerate}
			\item \textbf{Si} $d''_j = d_j$, \textbf{entonces} poner $\sigma''_j = \sigma_j$.
			\item \textbf{Si no, si} $d''_j = d'_j$, \textbf{entonces} poner $\sigma''_j = \sigma'_j$.
			\item \textbf{Si no}, \textbf{volver al paso 2}.
		\end{enumerate}
		\item \textbf{Devolver} $(M'',\sigma'')$.
	\end{enumerate}
	\item \textbf{Devolver} \textit{error}.
\end{enumerate}
\ealgoritmo

En la siguiente tabla se recogen los resultados de aplicar este algoritmo para distintos valores de $n$, con las mismas claves que se usaron en el caso anterior.

\begin{center}
		\begin{tabular}{|c|c|c|}
			\hline
			$n$ & Número de documentos & Tiempo \\
			\hline
			8 & $17$ & $0.000986$ segundos \\
			\hline
			16 & $1.679$ & $0.0229$ segundos \\
			\hline
			24 & $12.071$ & $0.1556$ segundos \\
			\hline
			32 & $38.320$ & $ 0.5392 $ segundos \\
			\hline
			
		\end{tabular}
\end{center}

Como vemos, este ataque comparado con la búsqueda por fuerza bruta es sumamente efectivo. Por ello, se dice que esta firma es de \textit{un solo uso}.

\subsection{Seguridad del esquema LD-OTS}

\section{Criptografía basada en códigos}

